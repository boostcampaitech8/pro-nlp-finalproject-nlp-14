services:
  postgres:
    image: postgres:15-alpine
    container_name: mit-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-mit}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-mitpassword}
      POSTGRES_DB: ${POSTGRES_DB:-mit}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-mit}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: mit-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  minio:
    image: minio/minio:latest
    container_name: mit-minio
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin}
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # LiveKit SFU Server
  livekit:
    image: livekit/livekit-server:latest
    container_name: mit-livekit
    networks:
      default:
        # 고정 IP - egress에서 외부 IP를 이 주소로 매핑하여 hairpin NAT 우회
        ipv4_address: 172.28.0.10
        # TURN 도메인 별칭 - egress가 turn.mit-hub.com으로 접속 시 livekit 컨테이너로 해석
        aliases:
          - turn.mit-hub.com
    ports:
      - "7880:7880"       # HTTP/WebSocket API
      - "7881:7881"       # WebRTC TCP
      - "7882:7882/udp"   # WebRTC UDP
      - "50000-50100:50000-50100/udp"  # RTC UDP 포트 범위
      - "3478:3478/udp"   # TURN UDP
      - "5349:5349"       # TURN TLS (nginx 443 충돌 회피)
      - "30000-30050:30000-30050/udp"  # TURN relay 포트 범위
    volumes:
      # TURN TLS 인증서 (프로덕션용)
      # 로컬은 빈 디렉토리 마운트로 충분
      - ${LIVEKIT_CERTS_PATH:-./certs}:/etc/letsencrypt:ro
    environment:
      # LIVEKIT_CONFIG: 전체 설정을 환경변수로 전달 (livekit.yaml 대체)
      # docker-compose가 .env의 ${} 변수를 치환함
      LIVEKIT_CONFIG: |
        port: 7880
        keys:
          ${LIVEKIT_API_KEY}: ${LIVEKIT_API_SECRET}
        rtc:
          tcp_port: 7881
          port_range_start: 50000
          port_range_end: 50100
          # 외부 접근 IP (로컬/프로덕션 모두 env로 제어)
          use_external_ip: ${LIVEKIT_USE_EXTERNAL_IP:-true}
          node_ip: ${LIVEKIT_NODE_IP:-}
        # 내장 TURN 서버 (NAT/방화벽 환경 대응)
        turn:
          enabled: ${LIVEKIT_TURN_ENABLED:-false}
          domain: ${LIVEKIT_TURN_DOMAIN:-}
          # 5349 포트 사용 (nginx 443 충돌 회피)
          tls_port: 5349
          udp_port: 3478
          # relay 포트 범위 - Docker 포트 매핑과 일치해야 함
          relay_range_start: 30000
          relay_range_end: 30050
          # TURN TLS 인증서 (필요 시 env로 지정)
          cert_file: ${LIVEKIT_TURN_CERT_FILE:-}
          key_file: ${LIVEKIT_TURN_KEY_FILE:-}
        redis:
          address: redis:6379
        logging:
          level: ${LIVEKIT_LOG_LEVEL:-info}
          json: false
        room:
          empty_timeout: 30
          max_participants: 20
        webhook:
          api_key: ${LIVEKIT_API_KEY}
          urls:
            - http://backend:8000/api/v1/livekit/webhook
    depends_on:
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:7880"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # LiveKit Egress (서버 측 녹음)
  livekit-egress:
    image: livekit/egress:latest
    container_name: mit-livekit-egress
    # Chrome 샌드박싱을 위한 권한 (v1.7.6+ 필수)
    cap_add:
      - SYS_ADMIN
    # 외부 템플릿 URL 접근을 위한 DNS 설정
    dns:
      - 8.8.8.8
      - 8.8.4.4
    # Egress Chrome에서 LiveKit WebRTC 연결을 위한 호스트 매핑
    # Docker Desktop for Mac hairpin NAT 우회: 외부 IP를 LiveKit 내부 IP로 매핑
    # TURN 도메인은 Docker 네트워크 별칭으로 livekit 컨테이너에 직접 연결
    extra_hosts:
      - "host.docker.internal:host-gateway"
      - "${LIVEKIT_NODE_IP}:172.28.0.10"
    environment:
      # 내부 네트워크 사용을 위한 설정
      EGRESS_INSECURE: "true"
      # EGRESS_CONFIG_BODY: 전체 설정을 환경변수로 전달 (egress.yaml 대체)
      # docker-compose가 .env의 ${} 변수를 치환함
      EGRESS_CONFIG_BODY: |
        api_key: ${LIVEKIT_API_KEY}
        api_secret: ${LIVEKIT_API_SECRET}
        ws_url: ws://livekit:7880
        redis:
          address: redis:6379
        s3:
          access_key: ${MINIO_ROOT_USER:-minioadmin}
          secret: ${MINIO_ROOT_PASSWORD:-minioadmin}
          endpoint: http://minio:9000
          bucket: recordings
          force_path_style: true
        log_level: debug
        cpu_cost:
          track_composite_cpu_cost: 2.0
          track_cpu_cost: 1.0
          room_composite_cpu_cost: 3.0
        template_base: /home/egress/templates
    depends_on:
      livekit:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped

  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: mit-backend
    # 내부 네트워크에서만 접근 (frontend nginx가 프록시)
    expose:
      - "8000"
    volumes:
      # Docker socket 마운트 (realtime-worker 시작용)
      - /var/run/docker.sock:/var/run/docker.sock
      # docker-compose.yml 마운트 (worker 시작 시 필요)
      - ./docker-compose.yml:/docker/docker-compose.yml:ro
      - ./.env:/docker/.env:ro
    environment:
      APP_ENV: ${APP_ENV:-production}
      DEBUG: ${DEBUG:-false}
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-mit}:${POSTGRES_PASSWORD:-mitpassword}@postgres:5432/${POSTGRES_DB:-mit}
      REDIS_URL: redis://redis:6379/0
      ARQ_REDIS_URL: ${ARQ_REDIS_URL:-redis://redis:6379/1}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-change-this-secret-key}
      ACCESS_TOKEN_EXPIRE_MINUTES: ${ACCESS_TOKEN_EXPIRE_MINUTES:-30}
      REFRESH_TOKEN_EXPIRE_DAYS: ${REFRESH_TOKEN_EXPIRE_DAYS:-7}
      CORS_ORIGINS: '["https://snsn.kr","http://localhost:3000","https://mit-hub.com","https://www.mit-hub.com"]'
      # MinIO 설정 (Docker 내부 네트워크)
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD:-minioadmin}
      # 외부에서 접근 가능한 스토리지 URL (nginx 프록시 경로)
      STORAGE_EXTERNAL_URL: ${STORAGE_EXTERNAL_URL:-https://www.mit-hub.com/storage}
      # LiveKit 설정
      LIVEKIT_API_KEY: ${LIVEKIT_API_KEY}
      LIVEKIT_API_SECRET: ${LIVEKIT_API_SECRET}
      LIVEKIT_WS_URL: ws://livekit:7880
      LIVEKIT_EXTERNAL_URL: ${LIVEKIT_EXTERNAL_URL:-wss://www.mit-hub.com/livekit}
      # OAuth 설정
      NAVER_CLIENT_ID: ${NAVER_CLIENT_ID}
      NAVER_CLIENT_SECRET: ${NAVER_CLIENT_SECRET}
      NAVER_REDIRECT_URI: ${NAVER_REDIRECT_URI}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GOOGLE_REDIRECT_URI: ${GOOGLE_REDIRECT_URI}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
      livekit:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  frontend:
    build:
      context: ..
      dockerfile: frontend/Dockerfile
      args:
        VITE_API_URL: /api/v1
        VITE_DEV_MODE: ${VITE_DEV_MODE:-false}
    container_name: mit-frontend
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    depends_on:
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  stt-worker:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: mit-stt-worker
    command: uv run python -m app.workers.run_worker
    environment:
      APP_ENV: ${APP_ENV:-production}
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-mit}:${POSTGRES_PASSWORD:-mitpassword}@postgres:5432/${POSTGRES_DB:-mit}
      REDIS_URL: redis://redis:6379/0
      ARQ_REDIS_URL: redis://redis:6379/1
      # MinIO 설정
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD:-minioadmin}
      # OpenAI STT 설정
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      STT_PROVIDER: ${STT_PROVIDER:-openai}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped

  # Realtime Worker (S2S 파이프라인: STT -> LLM -> TTS)
  # Backend에서 LiveKit room_started 웹훅 시 자동 시작
  # 직접 실행: docker compose run -d -e MEETING_ID=xxx realtime-worker
  realtime-worker:
    build:
      context: ../backend/worker
      dockerfile: Dockerfile
    # container_name 없음 - 동적으로 여러 인스턴스 생성 가능
    profiles:
      - worker  # 기본 실행에서 제외, 명시적 호출 시에만 실행
    environment:
      # MEETING_ID는 런타임에 주입
      MEETING_ID: ${MEETING_ID:-}
      # LiveKit 설정
      LIVEKIT_WS_URL: ws://livekit:7880
      LIVEKIT_API_KEY: ${LIVEKIT_API_KEY}
      LIVEKIT_API_SECRET: ${LIVEKIT_API_SECRET}
      # Clova Speech STT 설정
      CLOVA_STT_ENDPOINT: ${CLOVA_STT_ENDPOINT:-clovaspeech-gw.ncloud.com:50051}
      CLOVA_STT_SECRET: ${CLOVA_STT_SECRET:-}
      # Backend API 설정
      BACKEND_API_URL: http://backend:8000
      BACKEND_API_KEY: ${BACKEND_API_KEY:-}
      # Worker 설정
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      livekit:
        condition: service_healthy
      backend:
        condition: service_healthy
    restart: "no"  # 회의 종료 시 자연스럽게 종료

volumes:
  postgres_data:
  redis_data:
  minio_data:

networks:
  default:
    name: mit-network
    ipam:
      driver: default
      config:
        - subnet: 172.28.0.0/16
