# Helmfile - 선언적 Helm 배포
# 사용: helmfile -e local apply / helmfile -e prod apply

repositories:
  - name: bitnami
    url: https://charts.bitnami.com/bitnami
  - name: livekit
    url: https://helm.livekit.io
  - name: neo4j
    url: https://helm.neo4j.com/neo4j

environments:
  local:
    values:
      - values/local.yaml.gotmpl
  prod:
    values:
      - values/prod.yaml.gotmpl

---
releases:
  # ===========================================
  # MIT 앱 (ConfigMap, Secret, Deployments)
  # ===========================================
  - name: mit
    labels:
      type: app
      svc: mit
    chart: ./charts/mit
    namespace: {{ .Values.global.namespace }}
    createNamespace: true
    values:
      - global: {{ .Values.global | toYaml | nindent 10 }}
        backend: {{ .Values.backend | toYaml | nindent 10 }}
        frontend: {{ .Values.frontend | toYaml | nindent 10 }}
        database: {{ .Values.database | toYaml | nindent 10 }}
        redis: {{ .Values.redis | toYaml | nindent 10 }}
        livekit: {{ .Values.livekit | toYaml | nindent 10 }}
        jwt: {{ .Values.jwt | toYaml | nindent 10 }}
        app: {{ .Values.app | toYaml | nindent 10 }}
        worker: {{ .Values.worker | toYaml | nindent 10 }}
        neo4j: {{ .Values.neo4j | toYaml | nindent 10 }}
        ncp: {{ .Values.ncp | toYaml | nindent 10 }}
        oauth: {{ .Values.oauth | toYaml | nindent 10 }}
        ingress: {{ .Values.ingress | toYaml | nindent 10 }}
        resources:
          backend: {{ .Values.resources.backend | toYaml | nindent 12 }}
          frontend: {{ .Values.resources.frontend | toYaml | nindent 12 }}
          worker: {{ .Values.resources.worker | toYaml | nindent 12 }}

  # ===========================================
  # PostgreSQL
  # ===========================================
  - name: postgres
    labels:
      type: db
      svc: postgres
    chart: bitnami/postgresql
    namespace: {{ .Values.global.namespace }}
    values:
      # 한 곳에서만 쓰이는 값 - 하드코딩
      - architecture: standalone
        metrics:
          enabled: false
        # 공유 값 - values에서 참조
        global:
          postgresql:
            auth:
              password: {{ .Values.database.password }}
              postgresPassword: {{ .Values.database.password }}
        auth:
          password: {{ .Values.database.password }}
          postgresPassword: {{ .Values.database.password }}
          database: {{ .Values.database.name }}
          username: {{ .Values.database.user }}
        primary:
          persistence:
            enabled: true
            size: {{ .Values.resources.postgres.storage }}
          resources:
            requests: {{ .Values.resources.postgres.requests | toYaml | nindent 14 }}
            limits: {{ .Values.resources.postgres.limits | toYaml | nindent 14 }}
          service:
            type: ClusterIP

  # ===========================================
  # Redis
  # ===========================================
  - name: redis
    labels:
      type: infra
      svc: redis
    chart: bitnami/redis
    namespace: {{ .Values.global.namespace }}
    values:
      # 한 곳에서만 쓰이는 값 - 하드코딩
      - architecture: standalone
        auth:
          enabled: false
        replica:
          replicaCount: 0
        # 공유 값 - values에서 참조
        master:
          persistence:
            enabled: true
            size: {{ .Values.resources.redis.storage }}
          resources:
            requests: {{ .Values.resources.redis.requests | toYaml | nindent 14 }}
            limits: {{ .Values.resources.redis.limits | toYaml | nindent 14 }}
          service:
            type: ClusterIP

  # ===========================================
  # LiveKit
  # ===========================================
  - name: livekit
    labels:
      type: infra
      svc: livekit
    chart: livekit/livekit-server
    namespace: {{ .Values.global.namespace }}
    needs:
      - redis
    values:
      # 한 곳에서만 쓰이는 값 - 하드코딩
      - fullnameOverride: lk-server  # 'livekit'은 K8s 환경변수 LIVEKIT_PORT와 충돌
        livekit:
          key_file: keys.yaml
          rtc:
            tcp_port: {{ .Values.livekit.rtc.tcpPort }}
            port_range_start: {{ .Values.livekit.rtc.portRangeStart }}
            port_range_end: {{ .Values.livekit.rtc.portRangeEnd }}
            use_external_ip: {{ .Values.livekit.rtc.useExternalIp }}
            {{- if .Values.livekit.rtc.nodeIp }}
            node_ip: {{ .Values.livekit.rtc.nodeIp }}
            {{- end }}
          logging:
            level: info
            json: false
          room:
            empty_timeout: 5
            max_participants: 8
          # 공유 값 - values에서 참조
          redis:
            address: "{{ .Values.redis.host }}:{{ .Values.redis.port }}"
          webhook:
            api_key: {{ .Values.livekit.apiKey }}
            urls:
              {{- range .Values.livekit.webhookUrls }}
              - "{{ . }}"
              {{- end }}
        # Secret 참조 (mit-secrets의 keys.yaml 필드)
        storeKeysInSecret:
          enabled: true
          existingSecret: mit-secrets
        service:
          type: ClusterIP
        turn:
          enabled: false
        resources:
          requests: {{ .Values.resources.livekit.requests | toYaml | nindent 12 }}
          limits: {{ .Values.resources.livekit.limits | toYaml | nindent 12 }}

  # ===========================================
  # Neo4j (Graph DB)
  # ===========================================
  - name: neo4j
    labels:
      type: db
      svc: neo4j
    chart: neo4j/neo4j
    namespace: {{ .Values.global.namespace }}
    values:
      - fullnameOverride: neo4j  # 서비스 이름을 'neo4j'로 고정 (bolt://neo4j:7687)
        neo4j:
          name: "neo4j"
          edition: "community"
          password: {{ .Values.neo4j.password }}
          resources:
            cpu: {{ .Values.resources.neo4j.requests.cpu | quote }}
            memory: {{ .Values.resources.neo4j.memory | quote }}
        # Neo4j 메모리 설정 (docker-compose 동일)
        config:
          server.memory.heap.initial_size: "256m"
          server.memory.heap.max_size: "1g"
          server.memory.pagecache.size: "512m"
        services:
          neo4j:
            enabled: true
            spec:
              type: ClusterIP
            ports:
              http:
                enabled: true
              https:
                enabled: false
              bolt:
                enabled: true
              backup:
                enabled: false
          admin:
            enabled: true
            spec:
              type: ClusterIP
        volumes:
          data:
            mode: "defaultStorageClass"
            defaultStorageClass:
              requests:
                storage: {{ .Values.resources.neo4j.storage }}
