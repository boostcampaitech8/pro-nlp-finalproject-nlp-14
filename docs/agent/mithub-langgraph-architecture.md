# MitHub LangGraph Architecture

> 목적: MitHub의 LangGraph 기반 아키텍처 원칙과 설계 결정을 공유한다.
> 대상: 기획/개발 전원.
> 범위: 설계 원칙, 서브그래프 전략, State 설계 원칙.
> 비범위: 구현 규칙/개발 절차, 구체적인 디렉토리 구조/State 필드.
> 관련 문서: [MitHub Agent Overview](./mithub-agent-overview.md), [MitHub LangGraph Development Guideline](./mithub-langgraph-development-guideline.md), [MitHub LangGraph Coding Convention](./mithub-langgraph-coding-convention.md)

---

## 1. LangGraph 간략 설명

LangGraph는 LLM 기반 에이전트 워크플로우를 그래프로 모델링하는 프레임워크입니다.

그래프는 State, Nodes, Edges로 구성됩니다.

- **State**: 그래프 실행 동안 공유되는 작업 보드
  - 노드들이 State를 읽고, 일부 필드를 업데이트함
- **Node**: State → State patch 형태의 함수
  - 예: `create_plan`, `route_intent`, `retrieve_documents`, `generate_answer`
- **Edge**: 다음 노드로 이동하는 규칙
  - 조건부 엣지를 사용하여 복잡한 워크플로우를 설계할 수 있음 (순환형 워크플로우 설계 가능)

**LangGraph의 장점:**
- 상태 기반 라우팅이 명확해져서 복잡한 에이전트 흐름을 구조적으로 관리 가능
- 워크플로우를 서브그래프로 분리해 팀 단위 개발/확장에 유리
- 체크포인트 또는 재실행 같은 운영 관점 확장이 쉬움

---

## 2. 메인 그래프 + 서브그래프 사용 방식

MitHub에서는 하나의 거대한 그래프 대신, Orchestration(메인 그래프)와 기능별 서브그래프로 구성합니다.

### 2.1 메인 그래프 (Orchestration)의 역할

메인 그래프는 요청을 받아 **계획 수립 → 실행 위임 → 결과 평가**의 순환적 흐름을 조율합니다.

**핵심 책임:**
- 사용자 요청을 받아 실행 전략 수립
- 적절한 서브시스템(서브그래프)에 작업 위임
- 실행 결과를 평가하고, 필요시 재계획 수행
- 최종 응답 생성 또는 후속 액션 연결

**워크플로우 특성:**
- 결과 평가 후 재계획이 가능한 **순환형(cyclic) 구조** 채택
- 단방향 파이프라인이 아닌, 실행-평가-재계획 루프 지원

**라우팅 설계 원칙:**
- 라우팅 결정은 노드로 구현하고, 결정 근거를 State에 기록한다.
- 조건부 엣지는 State에 기록된 결정을 읽어 다음 노드로 이동한다.

### 2.2 서브그래프의 역할

서브그래프는 특정 기능(RAG 등)을 독립적인 작은 그래프로 구현합니다.

- **장점**: 복잡도를 분산하고, 기능 단위로 테스트/개선/교체가 쉬워짐
- **입력**: OrchestrationState의 일부 혹은 서브그래프 전용 State (최소 하나의 필드는 부모의 상태를 포함)
- **출력**: OrchestrationState의 일부

**통합 원칙:**
- 서브그래프는 메인 그래프의 하나의 노드로 참여한다.
- 부모/자식 State는 호환되어야 한다.

**서브그래프 통합 방식 비교:**

| 특징 | 옵션 A: Wrapper Node (수동 invoke) | 옵션 B: Native Subgraph (add_node) |
|-----|-----------------------------------|-----------------------------------|
| 구현 코드 | `def call_sub(state): return sub.invoke(state)` | `builder.add_node("sub", compiled_graph)` |
| 상태(State) 관리 | 수동 매핑 필요 (입/출력 변환 용이) | 자동 병합 (부모/자식 스키마가 호환되어야 함) |
| 시각화 (LangSmith) | 단일 노드(함수)로 표시됨 (내부 구조 숨김) | 내부 구조가 확장되어 상세히 보임 |
| 체크포인트(Persistence) | 서브그래프 내부 상태는 별도로 관리됨 | 부모 그래프와 체크포인트/메모리 공유 |
| 스트리밍 | 수동으로 제너레이터 처리 필요 | 자동 지원 (부모의 스트리밍 설정 승계) |

**결정**: `add_node("mit_search", mit_search_graph)` 방식 사용

### 2.3 State 공유 전략

루트 State를 중심으로 공유하며, 복잡한 서브그래프는 전용 State를 둘 수 있습니다.

- 전용 State는 루트 State와 호환 필드를 유지해야 함
- 순환 참조를 막기 위해 공통 모델은 전용 스키마 모듈에만 둡니다.

### 2.4 왜 이런 구조를 채택했는가?

메인 그래프와 서브그래프로 이루어진 현재의 구조를 채택하기 전 다음 3가지 방식에 대해 고민했습니다.

| 방식 | 장점 | 단점 |
|-----|------|------|
| **MCP처럼 외부 프로그램으로 분리** | 격리성, 스케일링 쉬움 | State(메모리) 공유가 어려움, 네트워크 비용 발생, 개발 속도 느림, 높은 디버깅 난이도 |
| **그래프를 나누고 서브그래프를 호출** | State 공유가 자연스러움, 복잡도 분산, 서브그래프 단위 테스트, 점진적 확장 용이 | 초기 구조 설계 어려움, 서브그래프 과다 분할 위험 |
| **하나의 거대한 그래프** | 초기 빠른 구현, 이동 규칙을 한 눈에 확인할 수 있음 (그래프가 단순한 초기에만) | 그래프 비대화, 팀 병렬개발 어려움, 기능별 테스트 어려움 |

**결정**: 초기 구조 설계가 어려운 대신, State 공유가 용이하고 병렬 개발이 가능한 **메인 그래프 + 서브그래프(2번)** 구조가 가장 적합하다고 판단

---

## 3. 향후 검토 사항

- OrchestrationState에 metadata (logging) 필드 추가 여부
- evaluator를 각각의 서브그래프에 둘지 혹은 하나의 독립적인 서브그래프로 구성할지
